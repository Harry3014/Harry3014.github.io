## 服务器组件

[设计动机](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#motivation)

- 完全运行在服务器，完全不打进包内，代码不会下载到客户端，帮助减少包的大小，改善启动时间

- 可以访问服务器的资源，例如数据库，文件系统等等[rfc]()

- 自动进行代码分割，以前可能通过动态引入进行懒加载

- 可以和客户端组件集成，通过 props 将数据从服务器组件传到客户端组件中去

- 计划添加 use 这样一个 hook，允许客户端组件加载数据

- 使用 use client 表明是客户端组件

- 服务器组件也有限制，不能使用 state 和 effect

### 与 ssr 的不同

ssr 是渲染成整段 html，然后可以快速显示内容给用户，但是需要通过水和才能交互。

仍然需要下载资源，然后解析，它是不区分服务端组件和客户端组件的。

可以二者结合。

### 渲染流程

[流程](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md#simplified-loading-sequence)

涉及到两个角色，需要一个额外的框架例如 next.js 处理路由和打包，还有一个就是 react 自身。

**初次加载**

服务器部分：

- 框架：处理路由，匹配应该渲染的组件，并且会把 url 上的参数传给组件

- react：渲染组件，宿主组件是 json 形式，客户端组件流化。遇到 suspense 可以会暂停，并先渲染 fallback，直到接触暂停时再重新渲染，并将结果流向客户端

- 框架再次处理 react 渲染出的内容，并将结果以流的形式传向客户端，数据格式并不是 html，而是渲染内容的描述。

```
1:I{"id":"./src/SearchField.js","chunks":["client2"],"name":""}
2:I{"id":"./src/EditButton.js","chunks":["client0"],"name":""}
3:"$Sreact.suspense"
0:["$","div",null,{"className":"main","children":[["$","section",null,{"className"....
```

客户端部分：

- 框架：收到流响应，把一行一行的内容给 react

- react：对响应进行反序列化，渲染宿主组件和客户端组件，这是逐步的，不用等到整个流完成。suspense 显示 fallback，等到所有服务器组件的渲染内容都被加载，所有内容呈现给用户。

**更新**

客户端部分：

- 框架：响应需求，请求渲染

服务器部分：

- 框架：跟初始渲染差不多

客户端部分：

- 框架：触发重新渲染

- react：将协调渲染更新，由于数据不是 html，所以还是可以保持当前的 UI 状态，例如焦点等等。

## hook 对象数据结构

```js
var hook = {
  memoizedState: null, // 保存状态
  baseState: null,
  baseQueue: null,
  queue: null, // 保存更新对象
  next: null, // 指向下一个hook
};
```

hook list 保存在`fiber.memoizedState`。

## ref 相关

### ref 绑定 dom

在 commitMutationEffect 之后的 commitLayoutEffect 阶段处理

```js
function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {
  if (finishedWork.flags & Ref) {
    commitAttachRef(finishedWork);
  }
}

function commitAttachRef(finishedWork) {
  finishedWork.ref.current = finishedWork.stateNode;
}
```

### forwardRef

forwardRef(render) 返回一个可以在 JSX 中渲染的 React 组件。

```js
function commitAttachRef(finishedWork) {
  var ref = finishedWork.ref;

  if (ref !== null) {
    var instance = finishedWork.stateNode;
    var instanceToUse;

    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;

      default:
        instanceToUse = instance;
    }

    if (typeof ref === "function") {
      // ref 对象可以是函数
      ref(instanceToUse);
    } else {
      ref.current = instanceToUse;
    }
  }
}
```

在 beginWork 时属于 case ForwardRef，会进行 render(props, ref) 调用，render 参数更像是普通组件的写法。

```js
function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
  var render = Component.render;
  var ref = workInProgress.ref;

  nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
}
```

### forwardRef 与 useImperativeHandle 配合使用

暴露命令式句柄而非真实的 DOM。

useImperativeHandle(ref, createHandle, dependencies?)

createHandle 函数返回想要暴露的内容，可以是任意类型。

useImperativeHandle 实际与 useLayoutEffect 添加的副作用一样，所以在 commitLayoutEffect 阶段执行。

```js
function mountImperativeHandle(ref, create, deps) {
  // Layout 类型的 effect
  mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}
```

imperativeHandleEffect 还会返回 cleanup 函数。

```js
function imperativeHandleEffect(create, ref) {
  if (typeof ref === "function") {
    var refCallback = ref;

    var _inst = create();

    refCallback(_inst);
    return function () {
      refCallback(null);
    };
  } else if (ref !== null && ref !== undefined) {
    var refObject = ref;

    var _inst2 = create();

    refObject.current = _inst2;
    return function () {
      refObject.current = null;
    };
  }
}
```

### ref 属性可以是一个函数

但是 useRef 和 createRef 返回的都是对象。

挂载的时候传入对应的 value，卸载时传入 null。

### useRef

返回的是`{current: xxx}`对象，这个对象存在`hook.memoizedState`
