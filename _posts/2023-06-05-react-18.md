## createRoot(domNode, options?)

[react 文档](https://zh-hans.react.dev/reference/react-dom/client/createRoot)

```js
function createRoot(container, options) {
  // ...

  root = createContainer(/*...*/);

  listenToAllSupportedEvents(container);

  return new ReactDOMRoot(root);
}
```

创建 root 的过程主要有以下环节：

- 创建第一个 Fiber：HostRoot
- 创建 fiber root，它的类型是 FiberRootNode
- 在 container 上监听所有事件

创建的几个对象它们之间的关系如下图：

<figure>
  <img src="/assets/images/full-fiber-tree.jpeg">
</figure>

也可以总结为：

- FiberRootNode.containerInfo = container
- FiberRootNode.current = HostRoot
- HostRoot.stateNode = FiberRootNode

返回的 ReactDOMRoot 有两个方法，render 和 unmount。

## 渲染前：创建 Lane

无论是第一次调用 render，还是后续组件更新 state，都会触发渲染，在进入渲染任务之前，都会创建一个 lane，简单列出几种触发渲染的情况。

- 初次渲染

```js
function updateContainer(element, fiberRootNode /*...*/) {
  // ...
  hostRootFiber = fiberRootNode.current;
  lane = requestUpdateLane(hostRootFiber /*...*/);
}
```

- 调用 useState hook 返回的 set 函数

```js
function dispatchSetState(fiber, queue, action) {
  // ...
  lane = requestUpdateLane(fiber);
}
```

- 调用 useReducer hook 返回的 dispatch

```js
function dispatchReducerAction(fiber, queue, action) {
  // ...
  lane = requestUpdateLane(fiber);
}
```

- class 组件调用 setState，forceUpdate 等等

```js
classComponentUpdater = {
  enqueueSetState: function (instance /*...*/) {
    // ...
    fiber = get(instance);
    lane = requestUpdateLane(fiber);
  },
};
```

### lane 的数据结构

lane 是一个数字，在 react 源码中以二进制的形式表示，react 预定义了很多种 lane，数值越小表示优先级越高，可以大致列出几类。

- 同步类型，优先级最高

```js
SyncLane = 0b0000000000000000000000000000001;
```

- 连续输入

```js
InputContinuousLane = 0b0000000000000000000000000000100;
```

- 默认

```js
InputContinuousLane = 0b0000000000000000000000000001000;
```

以上三种都可以算作同步，优先级是比较高的。

react 18 正式确立了 transition 这一概念，transition 也有特定的 lane，它的优先级比同步低，一共定义了 16 个 transition 的 lane。

lane 模型优点：可以进行位运算。

- 多个 lane 可以合并成 lanes 进行批处理
- react 可以根据优先级高低来调度任务执行的顺序，以达到更好的用户体验
- 利用 lane 确立优先级后，优先级不高的任务可以进行时间分片，这类任务可以中断，以让优先级更高的任务先执行

### 如何确定 lane

- 如果在 transition 过程中，分配一个 transition 类型的 lane，优先级较低
- 根据触发的事件类型确定 lane，react 给事件进行了分类，大致分为：离散型事件，例如 click，此类事件优先级很高；连续型事件，例如 scroll，优先级次之，还有默认类型和空闲类型，优先级依次降低。

```js
DiscreteEventPriority = SyncLane;
ContinuousEventPriority = InputContinuousLane;
DefaultEventPriority = DefaultLane;
IdleEventPriority = IdleLane;
```

- 还有其他可能设置优先级的情况，不深入研究了
- 可能返回 DefaultLane

## 渲染前：创建 update 对象和挂载 lane

### 创建 update 对象

在渲染前一件很重要的事是创建 update 对象，不同情况创建的 update 对象可能有些许差异，但是有一些内容是一致且必须的。

```js
update = {
  lane: lane, // 刚刚创建的lane
  next: null, // 指向下一个update对象
};
```

此外还需要附加上更新内容，这在 class 组件和使用 hook 更新状态时有些许差异。

class 组件更新状态和初次渲染使用的同样的属性`update.payload`，hook 则使用`update.action`

```js
// 初次渲染记录了要渲染的元素
update.payload = { element: element };
// class组件记录了要更新的state，这个state可能是函数
update.payload = payload;
// hooks也是记录了要更新的state，也可能是函数
update.action = action;
```

还可能有一些其他的属性，例如`eagerState | hasEagerState`等等。

### 将 update 对象保存起来

创建了 update 对象后需要将其保存起来，以便后续渲染使用。

class 组件和 HostRoot 将 update 对象保存在`fiber.updateQueue`中，而 hook 则是保存在`hook.queue`中，它们的最终结构都相似，是一个循环链表 circular list。

<figure>
  <img src="/assets/images/update-circular-list.png">
</figure>

### 挂载 lane

刚刚创建的 lane，除了保存在 update 对象中，还会挂载到 fiber 树上，而且是从当前 fiber 节点开始，一直挂载到 HostRoot，这样做就能表明哪个分支下是包含这个 update 的。

当前 fiber 节点是合并到`fiber.lanes`属性上，祖先节点合并到`parent.childLanes`属性上。

```js
function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
  // Update the source fiber's lanes
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
  var alternate = sourceFiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }

  // Walk the parent path to the root and update the child lanes.

  var node = sourceFiber;
  var parent = sourceFiber.return;

  while (parent !== null) {
    parent.childLanes = mergeLanes(parent.childLanes, lane);
    alternate = parent.alternate;

    if (alternate !== null) {
      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
    }

    node = parent;
    parent = parent.return;
  }

  if (node.tag === HostRoot) {
    var root = node.stateNode;
    return root;
  } else {
    return null;
  }
}
```
