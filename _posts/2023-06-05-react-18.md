---
title: "深入React18"
excerpt: ""
toc: true
toc_sticky: true
date: 2023-06-05
categories:
  - React
tags:
  - React
---

## 从创建 ReactDOMRoot 开始

[react 文档](https://zh-hans.react.dev/reference/react-dom/client/createRoot)

```js
function createRoot(container, options) {
  // ...

  root = createContainer(/*...*/);

  listenToAllSupportedEvents(container);

  return new ReactDOMRoot(root);
}
```

创建 root 的过程主要有以下环节：

- 创建第一个 Fiber：HostRoot
- 创建 fiber root，它的类型是 FiberRootNode
- 在 container 上监听所有事件

创建的几个对象它们之间的关系如下图：

<figure>
  <img src="/assets/images/full-fiber-tree.jpeg">
</figure>

也可以总结为：

- FiberRootNode.containerInfo = container
- FiberRootNode.current = HostRoot
- HostRoot.stateNode = FiberRootNode

返回的 ReactDOMRoot 有两个方法，render 和 unmount。

## 元素，Fiber 和 Virtual DOM 的关系

react 中并不存在 Virtual DOM 这种类型的对象，Virtual DOM 是一种设计概念。

react 使用声明式来描述 UI，react 将 UI 转化为另一种抽象的结构保存在内存当中，并通过 DOM render，native render 等渲染器与真实的渲染内容对应起来。所以称为 DOM 有一些不恰当，因为还可以渲染成 native 视图。

Virtual DOM 避免开发直接操作 DOM，当 UI 需要修改时，react 会在内部根据当前 Virtual DOM 的结构计算出变化的部分，并且计算过程经过优化，会衡量时间复杂度和空间复杂度，最后会批量修改真实渲染内容。

### 元素

react 使用声明式描述 UI，部分渲染内容可以转换为元素对象，使用 JSX 和 createElement 可以创建元素对象，元素一经创建就不应该再修改，生成的元素对象大致有下面几个属性。

- `$$typeof`

  它的值是一个 symbol，Symbol.for('react.element')

- type

  可能是任何类型，例如 string 表示宿主类型组件，function 表示函数组件，class 表示类组件

- props

  属性例如 children，className 等等

- key

  渲染列表时一定要提供稳定并唯一的 key

- ref

  传递的 ref

### fiber

渲染任务可以切分成颗粒更小的任务单元，每一个任务单元就是一个 fiber，可以中断渲染然后把主线程控制权让出一边优先级更高的任务执行。

- tag

  Fiber 的类型，<a href="https://github.com/facebook/react/blob/855b77c9bbee347735efcd626dda362db2ffae1d/packages/react-reconciler/src/ReactWorkTags.js" target="_blank">源码</a>中定义了很多种类型，例如下面这几个常见类型:

  ```javascript
  export const FunctionComponent = 0;
  export const ClassComponent = 1;
  // Before we know whether it is function or class
  export const IndeterminateComponent = 2;
  // Root of a host tree. Could be nested inside another node.
  export const HostRoot = 3;
  export const HostComponent = 5;
  ```

- key

  与元素上的 key 类似

- type

  与元素的 type 类似

- stateNode

  维护了 Fiber 的本地状态，例如 DOM 节点或者类组件的实例等等。

- return, child, sibling

  这三个属性使得不同的 Fiber 之间建立起了联系，`fiber.child`指向第一个子节点，`fiber.return`指向父节点，`fiber.sibling`指向下一个兄弟节点。

- index

  fiber 在同层级 children 中的 index。

- ref

  ref 相关

- pendingProps, memoizedProps

  `pendingProps`是处理 Fiber 前设置的属性，`memoizedProps`是处理完 Fiber 后设置的属性。

- memoizedState

  state 相关，用于创建输出。类组件：保存了 state。函数组件：保存了 hook。

- updateQueue

  类组件调用 setState 时创建的 update list 保存在这里。

  函数组件调用 effect 相关的 hooks 创建的 effect list 保存在这里。

  宿主组件在 completeWork 中计算出的属性变化对象数组保存在这里。

- flags, subtreeFlags, deletions

  副作用相关

- lanes, childLanes

  优先级相关

- alternate

  一个组件可能不止有一个 Fiber：`current` fiber 表示当前状态，`workInProgress` fiber 表示正在处理。`current.alternate === workInProgress`并且`workInProgress.alternate === current`。

## 如何判断是函数组件还是 class 组件

由于 class 组件继承了 Component，在 Component 的原型上有标记。

```js
Component.prototype.isReactComponent = {};
```

## 渲染阶段和提交阶段

一次渲染过程分为渲染阶段和提交阶段，渲染阶段必须是纯净的，它不修改真实的渲染内容，只会计算变化，提交阶段利用上一阶段计算出的内容统一修改真实渲染。

## 触发渲染

初次渲染，更新 state，调用 forceUpdate，都会触发渲染。

- 初次渲染

```js
function updateContainer(element, fiberRootNode /*...*/) {
  // ...
  hostRootFiber = fiberRootNode.current;
  lane = requestUpdateLane(hostRootFiber /*...*/);
}
```

- 调用 useState hook 返回的 set 函数

```js
function dispatchSetState(fiber, queue, action) {
  // ...
  lane = requestUpdateLane(fiber);
}
```

- 调用 useReducer hook 返回的 dispatch

```js
function dispatchReducerAction(fiber, queue, action) {
  // ...
  lane = requestUpdateLane(fiber);
}
```

- class 组件调用 setState，forceUpdate 等等

```js
classComponentUpdater = {
  enqueueSetState: function (instance /*...*/) {
    // ...
    fiber = get(instance);
    lane = requestUpdateLane(fiber);
  },
};
```

### 创建 lane

触发渲染时，都会创建一个 lane。

lane 是一个数字，在 react 源码中以二进制的形式表示，react 预定义了很多种 lane，数值越小表示优先级越高，可以大致列出几类。

- 同步类型，优先级最高

```js
SyncLane = 0b0000000000000000000000000000001;
```

- 连续输入

```js
InputContinuousLane = 0b0000000000000000000000000000100;
```

- 默认

```js
InputContinuousLane = 0b0000000000000000000000000001000;
```

以上三种都可以算作同步，优先级是比较高的。

react 18 正式确立了 transition 这一概念，transition 也有特定的 lane，它的优先级比同步低，一共定义了 16 个 transition 的 lane。

lane 模型优点：可以进行位运算。

- 多个 lane 可以合并成 lanes 进行批处理
- react 可以根据优先级高低来调度任务执行的顺序，以达到更好的用户体验
- 利用 lane 确立优先级后，优先级不高的任务可以进行时间分片，这类任务可以中断，以让优先级更高的任务先执行

### 如何确定 lane

- 如果在 transition 过程中，分配一个 transition 类型的 lane，优先级较低
- 根据触发的事件类型确定 lane，react 给事件进行了分类，大致分为：离散型事件，例如 click，此类事件优先级很高；连续型事件，例如 scroll，优先级次之，还有默认类型和空闲类型，优先级依次降低。

```js
DiscreteEventPriority = SyncLane;
ContinuousEventPriority = InputContinuousLane;
DefaultEventPriority = DefaultLane;
IdleEventPriority = IdleLane;
```

- 还有其他可能设置优先级的情况，不深入研究了
- 可能返回 DefaultLane

### 创建 update 对象

触发渲染时会创建 update 对象，不同情况创建的 update 对象可能有些许差异，但是有一些内容是一致且必须的。

```js
update = {
  lane: lane, // 刚刚创建的lane
  next: null, // 指向下一个update对象
};
```

此外还需要附加上更新内容，这在 class 组件和使用 hook 更新状态时有些许差异。

class 组件更新状态和初次渲染使用的同样的属性`update.payload`，hook 则使用`update.action`

```js
// 初次渲染记录了要渲染的元素
update.payload = { element: element };
// class组件记录了要更新的state，这个state可能是函数
update.payload = payload;
// hooks也是记录了要更新的state，也可能是函数
update.action = action;
```

还可能有一些其他的属性，例如`eagerState | hasEagerState`等等。

### 将 update 对象保存起来

创建了 update 对象后需要将其保存起来，以便后续渲染使用。

class 组件和 HostRoot 将 update 对象保存在`fiber.updateQueue`中，而 hook 则是保存在`hook.queue`中，它们的最终结构都相似，是一个循环链表 circular list。

<figure>
  <img src="/assets/images/update-circular-list.png">
</figure>

### 挂载 lane

刚刚创建的 lane，除了保存在 update 对象中，还会挂载到 fiber 树上，而且是从当前 fiber 节点开始，一直挂载到 HostRoot，这样做就能表明哪个分支下是包含这个 update 的。

当前 fiber 节点是合并到`fiber.lanes`属性上，祖先节点合并到`parent.childLanes`属性上。

```js
function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
  // Update the source fiber's lanes
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);

  // Walk the parent path to the root and update the child lanes.
  var node = sourceFiber;
  var parent = sourceFiber.return;

  while (parent !== null) {
    parent.childLanes = mergeLanes(parent.childLanes, lane);

    node = parent;
    parent = parent.return;
  }
}
```

除了将 lane 挂载到 fiber 树上，还会挂载到`FiberRootNode.pendingLanes`上。

```js
function markRootUpdated(root, updateLane) {
  mergeLanes(root.pendingLanes, updateLane);
}
```

## 安排渲染任务

根据 root 上的 lanes 为其安排任务，任务有不同的优先级，回调函数也不同。

```js
function ensureRootIsScheduled(root) {
  // Determine the next lanes to work on, and their priority.
  nextLanes = getNextLanes(root /*...*/);

  if (nextLanes === NoLanes) {
    // Special case: There's nothing to work on.
    return;
  }

  // We use the highest priority lane to represent the priority of the callback.
  newCallbackPriority = getHighestPriorityLane(nextLanes);

  if (newCallbackPriority === SyncLane) {
    queueMicrotask(() => {
      performSyncWorkOnRoot.bind(null, root)();
    });
  } else {
    scheduleCallback(performConcurrentWorkOnRoot.bind(null, root));
  }
}
```

- 获取接下来需要处理的 lanes
- 如果是较高的同步优先级，那么安排一个微任务执行 performSyncWorkOnRoot
- 否则安排一个宏任务执行 performConcurrentWorkOnRoot

[这篇文章](https://dev.to/ktmouk/how-does-react-18-work-inside-1c8l)介绍的更加详细。

## 渲染阶段

同步和并发的渲染有一些差异，但是本质并无差别。

```js
function performSyncWorkOnRoot(root) {
  lanes = getNextLanes(root);

  exitStatus = renderRootSync(root, lanes);

  if (exitStatus === RootFatalErrored) {
    // ...
  }

  root.finishedWork = root.current.alternate;

  commitRoot(root);

  // Before exiting, make sure there's a callback scheduled for the next pending level.
  ensureRootIsScheduled(root);
}
```

```js
function performConcurrentWorkOnRoot(root, didTimeout) {
  lanes = getNextLanes(root);

  shouldTimeSlice =
    !includesBlockingLane(root, lanes) &&
    !includesExpiredLane(root, lanes) &&
    !didTimeout;

  exitStatus = shouldTimeSlice
    ? renderRootConcurrent(root, lanes)
    : renderRootSync(root, lanes);

  // 根据返回的status做更加复杂的处理

  // 如果完成渲染，那么就可以提交
  commitRoot(root);

  ensureRootIsScheduled(root);
}
```

**时间分片**：并发任务回调不一定会时间分片，取决于接下来需要处理的 lanes。

如果不包含阻塞类型任务，并且不包含已失效的任务（饥饿问题），那么才进行时间分片。

目前已知的可能时间分片的情况是：transition 和 Suspense。

## 两种工作循环

```js
function renderRootSync() {
  // 准备一些全局变量

  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  return workInProgressRootExitStatus;
}
```

```js
function renderRootConcurrent() {
  // 准备一些全局变量
  do {
    try {
      workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  return workInProgressRootExitStatus;
}
```

准备工作主要在 prepareFreshStack 函数，值得关注的有：

- workInProgress 表示正在处理的 fiber，初始值是调用`createWorkInProgress(root.current)`，也就是 HostRoot 的 alternate。

- renderLanes，渲染的 lanes

两种工作循环，它们唯一的区别就是：在真正进入任务前，检查是否应该让出主线程的控制权。

```js
function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```

```js
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

```js
function shouldYieldToHost() {
  timeElapsed = now - startTime;

  if (timeElapsed < frameInterval) {
    // The main thread has only been blocked for a really short amount of time;
    // smaller than a single frame. Don't yield yet.
    return false;
  }

  return true;
}
```

如果这个并发任务超过了 react 规定的一帧的时间（默认 5ms），那么就需要主动让出主线程。

## 处理一个任务单元

```js
function performUnitOfWork(workInProgress) {
  current = workInProgress.alternate; // 可能是null

  next = beginWork(current, workInProgress, renderLanes);

  if (next === null) {
    completeUnitOfWork(workInProgress);
  } else {
    workInProgess = next;
  }
}
```

调用 beginWork 进行一个阶段的处理，如果返回新的任务单元（一般是这个 fiber 的 child），那么继续处理这个 fiber，否则就可以调用 completeUnitOfWork。

## beginWork

```js
function beginWork(current, workInProgress, renderLanes) {
  if (current !== null) {
    oldProps = current.memoizedProps;
    newProps = workInProgress.pendingProps;

    if (oldProps === newProps) {
      return attemptEarlyBailoutIfNoScheduledUpdate(
        current,
        workInProgress,
        renderLanes
      );
    }
  }

  switch (workInProgress.tag) {
  }
}
```

beginWork 也有一些性能优化，如果 props 没有改变，那么会尝试提前返回。

- 如果后代没有与此次渲染相关的任务，那么这个分支也无需再进行处理，返回 null，这个也使用 lane 进行判断

```js
// The children don't have any work either. We can skip them.
if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
  return null;
}
```

- 后代有相关任务，但自身没有，那么自己也无需处理，但是需要返回 child

```js
cloneChildFibers(current, workInProgress);
return workInProgress.child;
```

## 处理函数组件

在 beginWork 期间，函数组件会被调用，那么就会涉及到 hook。

```js
function renderWithHooks(current, workInProgess, Componennt, props) {
  if (current === null) {
    ReactCurrentDispatcher = HooksDispatcherOnMount;
  } else {
    ReactCurrentDispatcher = HooksDispatcherOnUpdate;
  }

  children = Component(props, secondArg);

  return children;
}
```

- 决定 hook 的 dispatcher，在挂载和更新时是不同的，hooks 在这两种情况下是不同的处理。
- 调用函数组件，返回需要渲染的内容

下面列出了一些 hook 的 API，它们的结构相似，都是调用 dispatcher 上对应的方法。

```js
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
```

hooks 依赖于一个稳定的调用顺序。

挂载时：

- 创建 hook
- 将 hook 存起来，存在`fiber.memoizedState`

创建的 hook 中有几个属性需要关注：

- queue
- next，将同一个 fiber 的 hook 连成一个 list

然后才是各个 hook 的具体逻辑

```js
function mountState(initialState) {
  dispatch = dispatchSetState.bind(null, workInProgess, hook.queue);
  return [initialState, dispatch];
}
```

```js
function mountReducer(reducer, initialArg, init) {
  if (init !== undefined) {
    initialState = init(initialArg);
  } else {
    initialState = initialArg;
  }

  dispatch = dispatchReducerAction.bind(null, workInProgress, hook.queue);
  return [initialState, dispatch];
}
```

在更新调用 useState 时，就会拿出`hook.queue`，如果满足`isSubsetOfLanes(renderLanes, update.lane)`，就会计算这个 update 得到一个新的 state。

在计算 state 完成后，如果前后 state 不同，那么会标记收到更新。

```js
if (!Object.is(newState, hook.memoizedState)) {
  markWorkInProgressReceivedUpdate();
}
```

mountEffect 大致是：

- 创建 effect 对象，它的结构是:

  - tag，因为 insertionEffect 和 layoutEffect 也是一样的处理方式，所以加以区分
  - create，就是传入的 setup 函数
  - destroy，cleanup 函数，不过要等到执行了 setup 函数才有值
  - deps，依赖
  - next，多个 effect 连成 list

- 因为渲染阶段还不需要执行副作用，所以需要把它保存起来

## 处理 class 组件

class 组件在 beginWork 会创建 class 的实例，保存在`fiber.stateNode`中。

在此期间调用

- `constructor(props)`，在挂载时
- `static getDerivedStateFromProps(props, state)`，返回一个对象更新 state，应该避免使用
- `shouldComponentUpdate(nextProps, nextState)`，只在不是由 forceUpdate 触发更新才会调用，返回 false 时，会尝试提前跳出 beginWork，不会调用 render 和 componentDidUpdate 方法。
- `render`

在更新时更新了组件实例的一些属性，例如`instance.props| instance.state`，所以我们才能使用新的`this.props | this.state`，记住 instance 本身是没有变的，还是引用的是之前的那个对象。

下面这个例子中，函数组件和类组件都是接受一个 name 属性，当点击 button 后 3 秒显示这个 name，但是在这 3 秒钟期间，如果以不同的 name 重新渲染了这两个组件，那么会有不同的效果。

函数组件还是会显示原来的 name，而类组件会显示新的 name。

函数组件：因为利用了闭包这一特性，所以还是显示原来的 name。

类组件：类组件实例 instance 并没有新创建，而是修改了 this.props，那引用新的 this.props.name 当然会得到新的 name。这其实也可以通过闭包解决，就是事先把 name 读出来放进闭包中。

```jsx
function App() {
  const [selectedFruit, setSelectedFruit] = useState("orange");

  return (
    <>
      <select
        value={selectedFruit}
        onChange={(e) => setSelectedFruit(e.target.value)}
      >
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>

      <ShowName name={selectedFruit} />
      <ClassShowName name={selectedFruit} />
    </>
  );
}

function ShowName({ name }) {
  return (
    <button
      onClick={() => {
        setTimeout(() => {
          alert(name);
        }, 3000);
      }}
    >
      Function Component
    </button>
  );
}

class ClassShowName extends Component {
  render() {
    return (
      <button
        onClick={() => {
          setTimeout(() => {
            alert(this.props.name);
          }, 3000);
        }}
      >
        Class Component
      </button>
    );
  }
}
```

## updateQueue 的处理

无论是函数组件还是类组件，在返回渲染内容前都需要准备好新的 states，因为渲染内容需要 state。

在函数组件中，useState，useReducer 会返回当前的 state 值，useContext 返回对应 context 的值。

在触发渲染时，创建的 update 保存在了`fiber.updateQueue`或者`hook.queue`中，此时需要处理这些 update 以更新 state。

处理的过程并不复杂，update list 是一个循环链表，遍历这个链表，但是不在此次 renderLanes 中的 update 不用处理，判断方法如下：

```js
if (isSubsetOfLanes(renderLanes, update.lane)) {
  // ...
} else {
  // ...
}
```

## 协调（diff 算法）

如果没有提前从 beginWork 退出，那么会进入不同 fiber 的处理过程，大多数类型都会进入协调过程。

协调：对比当前已经渲染的内容，计算出此次渲染需要变化的部分。这个过程主要在 fiber 树上进行，过程结束后会得到一个新的 fiber 树。渲染的内容大致由两种组件提供：

- 函数组件，执行函数组件得到渲染内容
- 类组件，执行类组件**实例**的 render 方法提供

<figure>
  <img src="/assets/images/current-wip-fiber-tree.jpeg">
</figure>

协调过程由 renconcileChildren 函数进入。

```js
function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  if (current === null) {
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes
    );
  } else {
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes
    );
  }
}
```

此时已经有的内容：

- current，当前已经渲染出结果的那个 fiber
- workInProgress，当前正在处理的 fiber
- nextChildren，需要渲染的内容，从函数组件或者类组件返回的

我们计算和得到的内容：得到全新的下一层 children fiber，并且返回第一个 child。

current 有两种情况，可能是 null，也就是当前渲染内容不包含它，这里有一个例外，那就是初次渲染时的 HostRoot，虽然此时没有任何已渲染的内容，但是 current 不是 null，而是我们在创建 root 时创建的第一个 fiber。

这两种情况都是调用同一个构造函数创建，只是参数不同，current 为 null 时不用记录子 fiber 的副作用（添加 Placement 标记）。

```js
function ChildReconciler(shouldTrackSideEffects) {}
```

```js
function reconcileChildFibers(
  returnFiber,
  currentFirstChild,
  newChild,
  lanes
) {}
```

`returnFiber`就是`workInProgess`

`currentFirstChild`是`current.child`，它可能是`null`。

`newChild`就是需要渲染的内容，它可能是任何类型的值，只是 react 只会处理特殊的几类，常见的类型就是 React 元素。

```js
if (typeof newChild === "object" && newChild !== null) {
  switch (newChild.$$typeof) {
    case REACT_ELEMENT_TYPE:
      return placeSingleChild(
        reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes)
      );

    case REACT_PORTAL_TYPE:
      return placeSingleChild(
        reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes)
      );

    case REACT_LAZY_TYPE:
      var payload = newChild._payload;
      var init = newChild._init;

      return reconcileChildFibers(
        returnFiber,
        currentFirstChild,
        init(payload),
        lanes
      );
  }

  if (isArray(newChild)) {
    return reconcileChildrenArray(
      returnFiber,
      currentFirstChild,
      newChild,
      lanes
    );
  }

  if (getIteratorFn(newChild)) {
    return reconcileChildrenIterator(
      returnFiber,
      currentFirstChild,
      newChild,
      lanes
    );
  }

  throwOnInvalidObjectType(returnFiber, newChild);
}

if (
  (typeof newChild === "string" && newChild !== "") ||
  typeof newChild === "number"
) {
  return placeSingleChild(
    reconcileSingleTextNode(
      returnFiber,
      currentFirstChild,
      "" + newChild,
      lanes
    )
  );
}

// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber, currentFirstChild);
```

根据提供的渲染内容进行判断，如果是 react 元素怎样处理，如果是数组怎样处理，如果是字符串、数字怎样处理，其他情况都直接删除所有的后代。

注意：这里删除并不是立即从 fiber 树中删除，而是记录在`returnFiber.deletions`中，并且会更新`returnFiber.flags`，flags 属性也是一个数字，与 lane 类似的二进制表示。

```js
returnFiber.deletions.push(childToDelete);
returnFiber.flags |= ChildDeletion;
```

我们看到上面有些方法最后都调用了类似`placeChild`的方法，这里是插入新 fiber 几点，或者**向后移动**fiber 节点时添加 Placement 标记。

```js
function placeChild(newFiber, lastPlacedIndex, newIndex) {
  newFiber.index = newIndex;

  var current = newFiber.alternate;

  if (current !== null) {
    var oldIndex = current.index;

    if (oldIndex < lastPlacedIndex) {
      // This is a move.
      newFiber.flags |= Placement;
      return lastPlacedIndex;
    } else {
      // This item can stay in place.
      return oldIndex;
    }
  } else {
    // This is an insertion.
    newFiber.flags |= Placement;
    return lastPlacedIndex;
  }
}
```

协调的过程 react 也有一些优化手段，要不然比较两棵树的时间复杂度太高了。经过优化，时间复杂度降低到 O(n)。

这些优化包括：

- 只在同级进行比较
- 如果 fiber 类型不同，那么 react 视作完全不同的内容，那么无法复用 fiber
- 开发者通过设置 key 属性标识这个 fiber 在不同次渲染中时是不变的

## 协调单个元素

在`returnFiber`的所有子节点中查找，key 和 type 都匹配，那么就可以使用`createWorkInProgess(fiber, element.props)`返回的 fiber，不匹配的其他子节点都删除。

## 协调多个元素

协调多个元素经历了几次遍历。

第一次遍历，测试条件是判断 key 是否匹配，如果匹配，假设 type 也匹配，那么考虑重用，否则重新创建 fiber，key 不匹配的话就跳出第一次遍历。

```js
if(oldFiber.key === newChild.key) {
  if(oldFiber.type === newChild.type){
    return createWorkInProgess(oldFiber, newChild.props)
  } else {
    return createNewFiber(newChild);
  }
} else {
  break;
}
```

如果嵌套了数组，那么按照 Fragment 处理。

根据第一次遍历的结果，决定还是否有下面的遍历。

如果 oldFiber 已经到了末尾，那么剩余的都需要创建新的 fiber。

```js
for (; newIdx < newChildren.length; newIdx++) {
  createNewFiber();
}
```

如果 newChildren 到了末尾，那么需要删除剩下的 oldFiber。

如果 oldFiber 和 newChild 都还有剩余，那么剩下的 oldFiber 生成一个 Map，key 是`fiber.key`或`fiber.index`。

```js
map = new Map();
while (oldFiber !== null) {
  if (oldFiber.key !== null) {
    map.set(oldFiber.key, oldFiber);
  } else {
    map.set(oldFiber.index, oldFiber);
  }

  oldFiber = oldFiber.sibling;
}
```

然后根据 key 或 index 去找匹配的 oldFiber，接下来的过程与上面差不多。

```js
for (; newIdx < newChildren.length; newIdx++) {
  newChild = newChild[newIdx];
  oldFiber = map.get(newChild.key === null ? newIdx : newChild.key);
}
```

考虑一个问题，假设有 abcde，变成 eabcd 和变成 bcdea，哪一种的标记变化的节点更多。

答案是：第一种。react 中定义 fiber 向后移动时才算移动，第一种情况 abcd 都是向后移动。

## lazy 返回组件

在 beginWork 处理 lazy 方法返回的组件时，会调用 lazy 的参数 load 函数，此函数应该返回 promise。

```js
lazy(load);
```

```js
thenable = load();

thenable.then((moduleObject) => {
  //...
});

throw xxx;
```

这里值得注意的是最后的抛出错误，在处理错误的函数中有下面这样的判断。

```js
if (
  value !== null &&
  typeof value === "object" &&
  typeof value.then === "function"
) {
  suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);

  if (suspenseBoundary !== null) {
  } else {
  }
}
```

当渲染时抛出一个等待的 promise，那么会尝试回滚到最近的 suspense 组件，渲染它的 fallback，等到 promise 被解决了，再重新渲染。

## completeUnitOfWork

如果 workInProgess 没有待处理任务了，那就可以调用 completeUnitOfWork。

```js
function completeUnitOfWork(completedWork) {
  do {
    completeWork(completedWork);

    if (completedWork.sibling) {
      workInProgess = completedWork.sibling;
      return;
    }

    completedWork = completedWork.return;
  } while (completedWork !== null);
}
```

## completeWork

completeWork 与 beginWork 在结构上类似，也是根据 fiber 的类型做不同的处理，值得关注的是 HostComponet 的处理，因为这里会创建 DOM。

```js
instance = workInProgess.stateNode;
if (instance !== null) {
  oldProps = current.memoizedProps;
  if (oldProps === newProps) {
    return;
  }

  updatePayload = diffProperties(instance, type, oldProps, newProps);
  workInProgess.updateQueue = updatePayload;

  if (updatePayload) {
    workInProgress.flags |= Update;
  }
}
```

DOM 保存在`fiber.stateNode`，如果是更新，那么就比较 props，将变化的属性计算出来保存在`workInProgress.updateQueue`中，并且添加 Update flag。

```js
instance = createElement(type, newProps);
appendAllChildren(instance, workInProgress);
workInProgess.stateNode = instance;
setInitialProperties(instance, type, props);
```

如果是挂载，那么需要先创建 DOM，然后把后代添加进来，设置属性。

在此期间，由于部分元素的一些事件不支持冒泡，所以无法使用事件委托，必须在这个 DOM 上添加事件监听器。例如 img 元素的 load 和 error 事件。

## 渲染阶段结束

到这里渲染阶段结束，我们得到了一颗全新的 fiber 树，并且部分 fiber 的 flags 中包含了一些标记，例如 Placement，Update，ChildDeletion。这个阶段并未真正修改 DOM。

渲染阶段也可能出现一些错误提前退出，当捕获到错误时，会进行判断，因为有些情况是 react 抛出的错误，例如在收到一个 thenable 的错误时，react 会向上寻找 Suspense，然后渲染 Suspense 提供的 fallback，然后接着渲染其他内容，而不是等到 thenable 解决后才渲染其他内容。

```js
if (
  value !== null &&
  typeof value === "object" &&
  typeof value.then === "function"
) {
  suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);

  if (suspenseBoundary !== null) {
    // 渲染suspense fallback
  } else {
    if (!includesSyncLane(rootRenderLanes)) {
      // react可以接受在并发情况下没有suspense
    } else {
      // 抛出一个错误
    }
  }
}
```

## 提交阶段开始 commitRoot

```js
subtreeHasEffects =
  (finishedWork.subtreeFlags &
    (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==
  NoFlags;
rootHasEffect =
  (finishedWork.flags &
    (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !==
  NoFlags;

if (subtreeHasEffects || rootHasEffect) {
  // ...
} else {
  root.current = finishedWork;
}

// Always call this before exiting `commitRoot`, to ensure that any additional work on this root is scheduled.

ensureRootIsScheduled(root);
```

根据`subtreeFlags`和`flags`判断是否有更新，没有更新就可以直接跳过。

提交阶段也是三个字阶段：

- 改变 DOM 之前
- 改变 DOM
- 改变 DOM 后

## commitBeforeMutationEffects

```js
function commitBeforeMutationEffectsOnFiber(finishedWork) {
  current = finishedWork.alternate;
  flags = finishedWork.flags;

  if ((flags & Snapshot) !== NoFlags) {
    swith(finishedWork.tag){
      case ClassComponent:
        if(current === null) {
          break;
        }
        prevProps = current.memoizedProps;
        prevState = current.memoizedState;
        instance = finishedWork.stateNode;

        snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
        instance.__reactInternalSnapshotBeforeUpdate = snapshot;
        break;
    }
  }
}
```

在修改 DOM 前这一阶段中，大部分有需要处理的情况只有 class 组件更新的情况。

如果 class 组件有 getSnapshotBeforeUpdate，那么在这里处理，返回的 snapshot 也存在对象实例中，以便 componentDidUpdate 生命周期函数使用。

在这里 fiber 树是从树从下向上处理，这里使用 subtreeFlags 做优化，如果子树中不包含这样的副作用，那么就可以跳过。

Snapshot 这个 flag 是在 beginWork 阶段处理 class 组件时添加上去，通过判断实例上是否有 getSnapshotBeforeUpdate。

```js
if (typeof instance.getSnapshotBeforeUpate === "function") {
  workInProgess |= Snapshot;
}
```

## commitMutationEffects

这个阶段就会真正修改 DOM，这个阶段的处理是一个递归过程。

先处理删除 fiber。

```js
deletions = parentFiber.deletions;

if (deletions !== null) {
  for (i = 0; i < deletions.length; i++) {
    childToDelete = deletions[i];
    commitDeletionEffects(root, parentFiber, childToDelete);
  }
}
```

删除 fiber 的过程也是递归的，也是根据 childToDelete 的类型做不同的处理。

HostComponent，HostText 这种宿主类型的 fiber 都找到它的 DOM 节点的 parent，然后调用 DOM API `removeChild`进行删除。

HostComponent 上如果有 ref，需要卸载 ref。

```js
function detachRef(deletedFiber) {
  ref = deletedFiber.ref;
  if (ref !== null) {
    if (typeof ref === "function") {
      ref(null);
    } else {
      ref.current = null;
    }
  }
}
```

FunctionComponent 在删除时，会选择调用清除 effect，effect 对象之前是保存在`fiber.updateQueue`上的。

类组件调用 componentWillUnMount 生命周期。

```js
do {
  destroy = effect.destory;
  if(destroy !=== undefined) {
    destroy();
  }
  effect = effect.next;
} while(effect !== firstEffect)
```

effect list 是一个循环链表。

在协调阶段中计算出的副作用大致有 ChildDeletion，Placement，删除已经处理过了，现在处理 Placement，也就是添加新 fiber 和重新排序 fiber。

在这个阶段主要就是利用 DOM API `insertBefore`和`appendChild`。

还有 DOM 元素属性的修改也在此时处理。

FunctionComponent 在这个阶段会处理，insertionEffect 的 cleanup 和 setup，layoutEffect 的 cleanup。

## commitLayoutEffects

FunctionComponent 处理 layoutEffect 的 setup，ClassComponent 调用 componentDidMount 或者 componentDidUpdate，HostComponent 绑定 DOM ref。

到现在 effect 似乎没有执行，effect 的执行可能跟此次宏任务同步执行，也可能在安排在未来的一个宏任务，这取决于此次渲染的优先级，如果是同步的优先级就高，那么就会在此次事件循环任务中执行。

## 渲染和提交结束

到这里渲染和提交阶段结束，如果在下次渲染时机到来之前，没有新的渲染任务，那么就会渲染出新的内容。

## hook 对象

在函数组件挂载和更新时可以调用 hooks，无论是挂载还是更新都会创建或者克隆 hook 对象，hook 对象有几个重要属性：

- memoizedState，已经记忆化的状态，例如 useState 返回的 currentState，useEffect 创建的 effect 对象
- queue，保存更新的一个队列
- next，指向下一个 hook 对象，是一个循环链表

```js
function mountWorkInProgressHook() {
  hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }

  return workInProgressHook;
}
```

```js
function updateWorkInProgressHook() {
  // 如果在current fiber没有对应的hook，那么会抛出错误
  if (nextCurrentHook === null) {
    throw new Error("Rendered more hooks than during the previous render.");
  }

  newHook = {
    memoizedState: currentHook.memoizedState,
    queue: currentHook.queue,
    next: null,
  };

  // ...
}
```

## effect hooks

useEffect, useInsertionEffect, useLayoutEffect 都是副作用相关的，他们只是执行时机不同。

useInsertionEffect 指定的副作用在改变 DOM 之前执行，此时也还未绑定 ref。

useLayoutEffect 在 DOM 变更后执行，但是此时浏览器还未执行绘制，如果需要阻塞浏览器绘制，那么应该使用这个 API。

useEffect 是在 DOM 变更后执行，但是不一定阻塞浏览器渲染，即使是 click 这样高优先级的用户交互行为也不一定。

effect 在挂载和更新时的逻辑时类似的，都会创建一个 effect 对象，在更新时只是会检查依赖是否改变。

effect 对象中几个重要的属性是：

- tag，是一个二进制表示数字，有 Insertion，Layout，Passive 三种，还有一个是 HasEffect 表示应该执行副作用，因为在依赖没有修改时是不需要执行副作用的。
- create，也就是 API 传入的 setup 函数
- destory，是第一次执行副作用 setup 函数后返回的 cleanup 函数
- deps，依赖
- next，指向下一个 effect 对象，也是一个循环链表，可以看到 react 使用了大量的循环链表

effect list 存放在`workInProgress.updateQueue`中，在进入`renderWithHooks`时包括 updateQueue 在内的一些属性被清空了。

```js
// 函数组件中保存了hook对象
workInProgess.memoizedState = null;
// 保存了effect对象
workInProgess.updateQueueue = null;
workInProgess.lane = NoLanes;
```

```js
function updateEffect(fiberFlags, hookFlags, create, deps) {
  if (currentHook !== null) {
    var prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;

    if (nextDeps !== null) {
      var prevDeps = prevEffect.deps;

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }

  currentlyRenderingFiber.flags |= fiberFlags;
  hook.memoizedState = pushEffect(
    HasEffect | hookFlags,
    create,
    destroy,
    nextDeps
  );
}
```

HasEffect 是重要的一个标记，如果依赖没有修改，那么这个副作用在更新时不会执行，比较依赖会使用`Object.is`。

## 创建 root 时监听事件

```js
function listenToAllSupportedEvents(rootContainerElement) {
  allNativeEvents.forEach(function (domEventName) {
    // We handle selectionchange separately because it
    // doesn't bubble and needs to be on the document.
    if (domEventName !== "selectionchange") {
      if (!nonDelegatedEvents.has(domEventName)) {
        listenToNativeEvent(domEventName, false, rootContainerElement);
      }

      listenToNativeEvent(domEventName, true, rootContainerElement);
    }
  });
}
```

nonDelegatedEvents 大致是一些不支持冒泡的事件。

```js
mediaEventTypes = [
  "abort",
  "canplay",
  "canplaythrough",
  "durationchange",
  "emptied",
  "encrypted",
  "ended",
  "error",
  "loadeddata",
  "loadedmetadata",
  "loadstart",
  "pause",
  "play",
  "playing",
  "progress",
  "ratechange",
  "resize",
  "seeked",
  "seeking",
  "stalled",
  "suspend",
  "timeupdate",
  "volumechange",
  "waiting",
];

// We should not delegate these events to the container, but rather
// set them on the actual target element itself. This is primarily
// because these events do not consistently bubble in the DOM.

nonDelegatedEvents = new Set(
  ["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(
    mediaEventTypes
  )
);
```

如果不在这些事件范围内，那么会在 root container 上分别绑定冒泡阶段和捕获阶段都会触发的监听器，否则只绑定捕获阶段触发的监听器。

这些 nonDelegatedEvents 会在 completeWork 创建 DOM 后直接在它上面绑定监听器。

绑定的监听器有一些不同，那就是在触发事件后设置不同的优先级，事件处理完成后再将优先级重置。

## 事件处理

触发事件后，进入监听器，可以根据`event.target`（触发事件的元素），找到对应的 fiber（fiber 对象会设置到 DOM 节点的一个属性上）。

然后从这个 fiber 开始，根据事件名称在 props 中寻找事件处理函数。

```js
function dispatchEvents(domEventName, inCapturePhase, targetFiber) {
  reactEventName = map.get(domEvent);
  if (inCapturePhase) {
    reactEventName += "Capture";
  }

  // 获取所有监听器
  listeners = [];
  instance = targetFiber;
  while (instance !== null) {
    stateNode = instance.stateNode;

    if (stateNode.tag === HostComponent) {
      listener = getListener(instance, reactEventName);
      if (listener !== null) {
        listeners.push(listener);
      }
    }

    instance = instance.return;
  }

  if (inCapturePhase) {
    // 捕获倒序执行
    // 生成合成事件
    event = new SyntheticEvent(/*...*/);
    for (let i = listeners.length - 1; i >= 0; i--) {
      excuteDispatch(event, listeners[i]);
      if (event.isPropagationStopped()) {
        break;
      }
    }
  } else {
  }
}
```
